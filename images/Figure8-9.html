<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Figure 8-9</title>
    <style>
			body { margin: 0; }
			canvas { width: 90%; height: 90% }
		</style>
  </head>
  <body> 
    <script src="../javascript/three.js"></script>
    <script>
						//https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene

						//To actually be able to display anything with three.js, we need three things: scene, camera and renderer, so that we can render the scene with camera.
						var scene = new THREE.Scene();
																//FOV (degrees), aspect ratio, near plane, far plane
						var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
						var renderer = new THREE.WebGLRenderer();
						renderer.setClearColor( 0xffffff, 1.0 );
						renderer.setSize( window.innerWidth, window.innerHeight );
      
      	var pointLight = new THREE.PointLight(0xFFFFFF);
        pointLight.position.x = 100;
        pointLight.position.y = 50;
        pointLight.position.z = 130;
        // antialiasing not working on iPad...
        pointLight.shadow.mapSize.width = 1024; // default is 512
        pointLight.shadow.mapSize.height = 1024; // default is 512
        scene.add(pointLight);

						//Last but not least, we add the renderer element to our HTML document. This is a <canvas> element the renderer uses to display the scene to us.
						document.body.appendChild( renderer.domElement );
      
      
      
      ///lines
      
      //create a  LineBasicMaterial
const material0 = new THREE.LineBasicMaterial( { color: 0xffffff } );
      const points0 = [];
points0.push( new THREE.Vector3( - 10, -5, -90 ) );
points0.push( new THREE.Vector3( -10, -5, 0 ) );
points0.push( new THREE.Vector3( -10, -5, 60 ) );
const geometry0 = new THREE.BufferGeometry().setFromPoints( points0 );
const line0 = new THREE.Line( geometry0, material0 );
//scene.add(line0);

const points1 = []; 
points1.push( new THREE.Vector3( - 20, -5, -90 ) );
points1.push( new THREE.Vector3( -20, -5, 0 ) );
points1.push( new THREE.Vector3( -20, -5, 60 ) );
const geometry1 = new THREE.BufferGeometry().setFromPoints( points1 );
const line1 = new THREE.Line( geometry1, material0 );
//scene.add(line1);
      
      const points2 = []; 
points2.push( new THREE.Vector3( 10, -5, -90 ) );
points2.push( new THREE.Vector3( 10, -5, 0 ) );
points2.push( new THREE.Vector3( 10, -5, 60 ) );
const geometry2 = new THREE.BufferGeometry().setFromPoints( points2 );
const line2 = new THREE.Line( geometry2, material0 );
//scene.add(line2);
      
      
      const points3 = []; 
points3.push( new THREE.Vector3(  20, -5, -90 ) );
points3.push( new THREE.Vector3(20, -5, 0 ) );
points3.push( new THREE.Vector3( 20, -5, 60 ) );
const geometry3 = new THREE.BufferGeometry().setFromPoints( points3 );
const line3 = new THREE.Line( geometry3, material0 );
//scene.add(line3);
      
            const points4 = []; 
points4.push( new THREE.Vector3(  0, -5, -90 ) );
points4.push( new THREE.Vector3(0, -5, 0 ) );
points4.push( new THREE.Vector3( 0, -5, 60 ) );
const geometry4 = new THREE.BufferGeometry().setFromPoints( points4 );
const line4 = new THREE.Line( geometry4, material0 );
//scene.add(line4);
      
            const points5 = []; 
points5.push( new THREE.Vector3(  30, -5, -90 ) );
points5.push( new THREE.Vector3(30, -5, 0 ) );
points5.push( new THREE.Vector3( 30, -5, 60 ) );
const geometry5 = new THREE.BufferGeometry().setFromPoints( points5 );
const line5 = new THREE.Line( geometry5, material0 );
//scene.add(line5);
      
            const points6 = []; 
points6.push( new THREE.Vector3(  -30, -5, -90 ) );
points6.push( new THREE.Vector3(-30, -5, 0 ) );
points6.push( new THREE.Vector3( -30, -5, 60 ) );
const geometry6 = new THREE.BufferGeometry().setFromPoints( points6 );
const line6 = new THREE.Line( geometry6, material0 );
//scene.add(line6);
      
      const materialR = new THREE.LineBasicMaterial( { color: 0xffff00 } );
                  const points7 = []; 
points7.push( new THREE.Vector3(  -50, -5, -10 ) );
points7.push( new THREE.Vector3( -7, -5, -10 ) );
const geometry7 = new THREE.BufferGeometry().setFromPoints( points7 );
const line7 = new THREE.Line( geometry7, materialR );
scene.add(line7);
      
   
                  const points8 = []; 
points8.push( new THREE.Vector3(  23, -5, 20 ) );
points8.push( new THREE.Vector3( -7, -5, -10 ) );
const geometry8 = new THREE.BufferGeometry().setFromPoints( points8 );
const line8 = new THREE.Line( geometry8, materialR );
scene.add(line8);
            
                  const points9 = []; 
points9.push( new THREE.Vector3(  0, -5, -15 ) );
points9.push( new THREE.Vector3( 30, -5, -45 ) );
const geometry9 = new THREE.BufferGeometry().setFromPoints( points9 );
const line9 = new THREE.Line( geometry9, materialR );
scene.add(line9);
            
      
       ///////////////////////////////////
      //
      // Plane
      //
      ///////////////////////////////////


      var XYsquareGeometry = new THREE.PlaneGeometry(250,220);

      var squareMaterial = new THREE.MeshBasicMaterial({ 
                  color:0x367a91, transparent:false, opacity:5, side:THREE.DoubleSide 
                });
      var XYsquareMesh = new THREE.Mesh(XYsquareGeometry, squareMaterial); 

     XYsquareMesh.applyMatrix4(new THREE.Matrix4().makeRotationX( Math.PI/2 ));    
            XYsquareMesh.position.set(0.0, -5.05, -30);
      scene.add(XYsquareMesh); 
      
      
const geometryS = new THREE.SphereGeometry(5, 32, 16 );
const  materialS1 = new THREE.MeshPhongMaterial( { color: 0xeeeeee, transparent:false, opacity: 0.3 } );
const sphere1 = new THREE.Mesh( geometryS, materialS1 );
      sphere1.position.set (-20,0,-40);
scene.add( sphere1 );
      

const  materialS2 = new THREE.MeshPhongMaterial( { color: 0xff2222, transparent:false, opacity: 0.3 } );
const sphere2 = new THREE.Mesh( geometryS, materialS2 );
      sphere2.position.set (0,0,-40);
scene.add( sphere2 );
      
      
      var sphere1x=-50;
      var sphere2x=0;
      var sphere1z=-10;
      var sphere2z=-15;
      var sphere1max=-7;
      var cameraX=00;
      var cameraY=80;
      var cameraLookAtx = 0;
      camera.position.x = 0;
      camera.position.y = 80;
      camera.position.z = -10;
        camera.lookAt(new THREE.Vector3(0,-40,-10));
      //We're not actually rendering anything yet. For that, we need what's called a render or animate loop.
      var animate = function () {

        //This will create a loop that causes the renderer to draw the scene every time the screen is refreshed (on a typical screen this means 60 times per second). If you're new to writing games in the browser, you might say "why don't we just create a setInterval ?" The thing is - we could, but requestAnimationFrame has a number of advantages. Perhaps the most important one is that it pauses when the user navigates to another browser tab, hence not wasting their precious processing power and battery life.
        requestAnimationFrame( animate );

        //XYsquareMesh.position.set(0.0, planeLevel, 0);
        sphere1.position.set (sphere1x,0,sphere1z);
        sphere2.position.set (sphere2x,0,sphere2z);


				if (sphere1x < sphere1max) { sphere1x += 0.3; }
				if (sphere1x >= sphere1max) { 


          if(sphere2x < 30) {
            								//sphere2x =0;
                            //sphere1x=-50;
                            //sphere1z=-10;
                            //sphere2z=-15;
                      sphere2x += 0.15;
          						sphere1x += 0.15;
          						sphere2z += -0.15;
          						sphere1z += 0.15;
                                   } 
          if(sphere2x > 30) {
            if (line9.position.x > -49.5) {
              line9.position.x += -0.5;
            }
            if (line8.position.x > -23.5) {
              line8.position.x += -0.5;
            }
            if (line9.position.z < 0.8) {
              line9.position.z += 0.2;
            }
            if (line8.position.z > -23.6) {
              line8.position.z += -0.5;
            }
            if (line8.position.x < -21 ){
              if (line8.scale.x > line7.scale.x*0.707) {
                line8.scale.x += -0.005;
                line8.scale.z += -0.005;
              }
              if (line9.scale.x > line7.scale.x*0.707) {
                line9.scale.x += -0.005;
                line9.scale.z += -0.005;
              }
            }
          }
        
        }		

        renderer.render( scene, camera );
      };

			animate();


		</script>
  </body>
</html>
